package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	// "github.com/golang/protobuf/protoc-gen-go/generator"
	pbParser "github.com/codelity-co/codelity-protobuf-parser"
)

const (
	serviceName = "\nservice "
)

//server template to create trigger support files
var registryServerTemplate = template.Must(template.New("").Parse(`// This file registers with grpc service. This file was auto-generated by mashling at
// {{ .Timestamp }}
package {{.Package}}

import (
	{{if .UnaryMethodInfo}}
	"encoding/json"
	"fmt"
	"strings"
	"context"
	{{end}}
	"errors"
	servInfo "github.com/codelity-co/flogo-grpc-trigger"
	"github.com/golang/protobuf/jsonpb"
	"google.golang.org/grpc"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
)
{{$serviceName := .RegServiceName}}
{{$protoName := .ProtoName}}
{{$option := .Option}}
type {{$serviceName}}{{$option}} struct {
	trigger *servInfo.Trigger
	serviceInfo *servInfo.ServiceInfo
}

var {{$serviceName}}{{$option}}Info = &servInfo.ServiceInfo{
	ProtoName: "{{$protoName}}",
	ServiceName: "{{$serviceName}}",
}

var service *{{$serviceName}}{{$option}}

func init() {
	servInfo.ServiceRegistery.RegisterServerService(&{{$serviceName}}{{$option}}{serviceInfo: {{$serviceName}}{{$option}}Info})
}

// RunRegisterServerService registers server method implimentaion with grpc
func (s *{{$serviceName}}{{$option}}) RunRegisterServerService(serv *grpc.Server, trigger *servInfo.Trigger) {
	service = &{{$serviceName}}{{$option}}{
		trigger: trigger,
		serviceInfo: {{$serviceName}}{{$option}}Info,
	}
	Register{{$serviceName}}Server(serv, service)
}

func (s *{{$serviceName}}{{$option}}) RegisterHttpMuxHandler(ctx context.Context, mux *runtime.ServeMux) error {
	return Register{{$serviceName}}HandlerServer(ctx, mux, service)
}

{{- range .UnaryMethodInfo }}

func (s *{{$serviceName}}{{$option}}) {{.MethodName}}(ctx context.Context, req *{{.MethodReqName}}) (res *{{.MethodResName}},err error) {

	methodName := "{{.MethodName}}"
	serviceName := "{{$serviceName}}"

	grpcData := make(map[string]interface{})
	grpcData["methodName"] = methodName
	grpcData["serviceName"] = serviceName
	grpcData["contextData"] = ctx
	grpcData["reqData"] = req

	_, replyData, err := s.trigger.CallHandler(grpcData)

	if err != nil {
		s.trigger.Logger.Error("ServerStubError: ", err.Error())
		return nil, err
	}

	typeHandRes := fmt.Sprintf("%T", replyData)
	if strings.Compare(typeHandRes, "*status.statusError") == 0 {
		s.trigger.Logger.Error("ServerStubError: statusError")
		return res, replyData.(error)
	}
	typeMethodRes := fmt.Sprintf("%T", res)
	if strings.Compare(typeHandRes, typeMethodRes) == 0 {
		s.trigger.Logger.Debug("Casting Handler Resp to Method Resp")
		res = replyData.(*{{.MethodResName}})
	} else  if replyData != nil {
		var errValue = replyData.(map[string]interface{})["error"]
		if errValue != nil && len(errValue.(string)) != 0 {
			s.trigger.Logger.Error("ServerStubError: ", errValue.(string))
			return res, errors.New(errValue.(string))
		} else {
			rDBytes, err := json.Marshal(replyData)
			if err != nil {
				s.trigger.Logger.Error("ServerStubError: ", err.Error())
				return res, err
			}
			s.trigger.Logger.Debug("Reply Data from Call Handler: ", string(rDBytes))
			res = &{{.MethodResName}}{}
			err = jsonpb.UnmarshalString(string(rDBytes), res)
			if err != nil {
				s.trigger.Logger.Error("ServerStubError: ", err.Error())
				return res, err
			}
		}
	} else {
		return nil, errors.New("Exception at gateway end")
	}

	//User implementation area

	return res, err
}

{{- end }}

{{- range .ServerStreamMethodInfo }}

func (s *{{$serviceName}}{{$option}}) {{.MethodName}}(req *EmptyReq, sReq {{$serviceName}}_{{.MethodName}}Server) error {

	methodName := "{{.MethodName}}"
	serviceName := "{{$serviceName}}"

	grpcData := make(map[string]interface{})
	grpcData["methodName"] = methodName
	grpcData["serviceName"] = serviceName
	grpcData["reqdata"] = req
	grpcData["strmReq"] = sReq

	_, data, err := s.trigger.CallHandler(grpcData)

	if err != nil {
		s.trigger.Logger.Error("ServerStubError: ", err.Error())
		return err
	}

	if data != nil && data.(map[string]interface{})["error"] != nil {
		s.trigger.Logger.Error("ServerStubError from end server: ", data.(map[string]interface{})["error"])
		return errors.New(data.(map[string]interface{})["error"].(string))
	}
	return nil
}

{{- end }}

{{- range .ClientStreamMethodInfo }}

func (s *{{$serviceName}}{{$option}}) {{.MethodName}}(cReq {{$serviceName}}_{{.MethodName}}Server) error {

	methodName := "{{.MethodName}}"
	serviceName := "{{$serviceName}}"

	grpcData := make(map[string]interface{})
	grpcData["methodName"] = methodName
	grpcData["serviceName"] = serviceName
	grpcData["strmReq"] = cReq

	_, data, err := s.trigger.CallHandler(grpcData)

	if err != nil {
		s.trigger.Logger.Error("ServerStubError: ", err.Error())
		return err
	}

	if data != nil && data.(map[string]interface{})["error"] != nil {
		s.trigger.Logger.Error("ServerStubError from end server: ", data.(map[string]interface{})["error"])
		return errors.New(data.(map[string]interface{})["error"].(string))
	}
	return nil
}

{{- end }}

{{- range .BiDiStreamMethodInfo }}

func (s *{{$serviceName}}{{$option}}) {{.MethodName}}(bdReq {{$serviceName}}_{{.MethodName}}Server) error {

	methodName := "{{.MethodName}}"
	serviceName := "{{$serviceName}}"

	grpcData := make(map[string]interface{})
	grpcData["methodName"] = methodName
	grpcData["serviceName"] = serviceName
	grpcData["strmReq"] = bdReq

	_, data, err := s.trigger.CallHandler(grpcData)

	if err != nil {
		s.trigger.Logger.Error("ServerStubError: ", err.Error())
		return err
	}

	if data != nil && data.(map[string]interface{})["error"] != nil {
		s.trigger.Logger.Error("ServerStubError from end server: ", data.(map[string]interface{})["error"])
		return errors.New(data.(map[string]interface{})["error"].(string))
	}
	return nil
}

{{- end }}

func (s *{{$serviceName}}{{$option}}) mustEmbedUnimplemented{{$serviceName}}Server() {}

func (s *{{$serviceName}}{{$option}}) ServiceInfo() *servInfo.ServiceInfo {
	return s.serviceInfo
}

`))

var (
	protoPath     string
	protoFileName string
	protoContent  []byte
	appPath       string
	cmdExePath    string
)

// MethodInfoTree holds method information
type MethodInfoTree struct {
	MethodName    string
	MethodReqName string
	MethodResName string
	serviceName   string
}

// ProtoData holds proto file data
type ProtoData struct {
	Timestamp              time.Time
	Package                string
	UnaryMethodInfo        []MethodInfoTree
	ClientStreamMethodInfo []MethodInfoTree
	ServerStreamMethodInfo []MethodInfoTree
	BiDiStreamMethodInfo   []MethodInfoTree
	AllMethodInfo          []MethodInfoTree
	ProtoImpPath           string
	RegServiceName         string
	ProtoName              string
	Option                 string
	Stream                 bool
}

var (
	packageName = flag.String("package", "main", "package name")
)

func main() {
	flag.Parse()
	fmt.Println("Running build...")

	appPath, _ = os.Getwd()
	flogoJSON := filepath.Join(appPath, "..", "flogo.json")
	_, fileErr := os.Stat(flogoJSON)
	if fileErr != nil {
		// look in parent directory
		flogoJSON = filepath.Join(appPath, "..", "..", "flogo.json")
		_, err := os.Stat(flogoJSON)
		if err != nil {
			log.Println(fmt.Errorf("Cannot find flogo.json file: %s", err.Error()))
		}
	}

	log.Printf("appPath has been set to: %s\n", appPath)

	// Read the flogo.json file to get the proto name and proto content
	inputJSON, err := ioutil.ReadFile(flogoJSON)
	if err != nil {
		log.Println(fmt.Errorf("Error reading json file: %s", err.Error()))
	}

	var data map[string]interface{}
	if err := json.Unmarshal(inputJSON, &data); err != nil {
		log.Println(fmt.Errorf("Error parsing json: %s", err.Error()))
	}

	// parse json to find trigger with protoFile field
	triggers := data["triggers"].([]interface{})
	for _, trigger := range triggers {
		trigger := trigger.(map[string]interface{})
		settings := trigger["settings"].(map[string]interface{})
		if _, ok := settings["protoFile"]; ok {
			if _, okk := settings["protoFile"].(map[string]interface{}); okk {
				// file picker
				protoFile := settings["protoFile"].(map[string]interface{})
				protoFileName = protoFile["filename"].(string)
				protoContent = []byte(protoFile["content"].(string))
				break
			} else {
				// text box
				fmt.Println(os.Getwd())
				protoFileName = settings["protoName"].(string) + ".proto"
				protoContent, err = ioutil.ReadFile(settings["protoFile"].(string))
				if err != nil {
					panic(err)
				}
				break
			}
		}
	}

	// Create a temp proto file with the protoContent
	protoPath = filepath.Join(appPath, protoFileName)
	fmt.Printf("protoPath:[%s] protoFileName:[%s]\n", protoPath, protoFileName)

	err = ioutil.WriteFile(protoPath, protoContent, 0644)
	if err != nil {
		panic(err)
	}

	// Generate support files
	err = GenerateSupportFiles(appPath)
	if err != nil {
		panic(err)
	}

	// cleanup build.go, shim_support.go and <fileName>.proto
	os.Remove(filepath.Join(appPath, "build.go"))
	os.Remove(filepath.Join(appPath, "shim_support.go"))
	os.Remove(protoPath)

	log.Println("Completed build!")
}

// GenerateSupportFiles creates auto genearted code
func GenerateSupportFiles(path string) error {

	// log.Println("Generating pb files...")
	// err := generatePbFiles()
	// if err != nil {
	// 	return err
	// }

	// log.Println("Generating grpc files...")
	// err = generateGrpcFiles()
	// if err != nil {
	// 	return err
	// }

	log.Println("Getting proto data...")
	pdArr, err := getProtoData()
	if err != nil {
		return err
	}

	// refactoring streaming methods and unary methods
	pdArr = arrangeProtoData(pdArr)

	log.Println("Creating trigger support files...")
	err = generateServiceImplFile(pdArr, "GrpcServer")
	if err != nil {
		return err
	}

	log.Println("Support files created.")
	return nil
}

// Exec executes a command within the build context.
func Exec(name string, arg ...string) error {
	cmd := exec.Command(name, arg...)
	if len(cmdExePath) != 0 {
		cmd.Dir = cmdExePath
		cmdExePath = ""
	}
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("Error executing command: %s \n %s", string(output), err.Error())
	}
	return nil
}

// arrangeProtoData refactors different types of methods from all method info list
func arrangeProtoData(pdArr []ProtoData) []ProtoData {

	for index, protoData := range pdArr {
		for _, mthdInfo := range protoData.AllMethodInfo {
			clientStrm := false
			servrStrm := false

			if strings.Contains(mthdInfo.MethodReqName, "stream ") {
				mthdInfo.MethodReqName = strings.Replace(mthdInfo.MethodReqName, "stream ", "", -1)
				clientStrm = true
				protoData.Stream = true
			}
			if strings.Contains(mthdInfo.MethodResName, "stream ") {
				mthdInfo.MethodResName = strings.Replace(mthdInfo.MethodResName, "stream ", "", -1)
				servrStrm = true
				protoData.Stream = true
			}
			if !clientStrm && !servrStrm {
				protoData.UnaryMethodInfo = append(protoData.UnaryMethodInfo, mthdInfo)
			} else if clientStrm && servrStrm {
				protoData.BiDiStreamMethodInfo = append(protoData.BiDiStreamMethodInfo, mthdInfo)
			} else if clientStrm {
				protoData.ClientStreamMethodInfo = append(protoData.ClientStreamMethodInfo, mthdInfo)
			} else if servrStrm {
				protoData.ServerStreamMethodInfo = append(protoData.ServerStreamMethodInfo, mthdInfo)
			}
		}
		pdArr[index] = protoData
	}

	return pdArr
}

// getProtoData reads proto and returns proto data present in proto file
func getProtoData() ([]ProtoData, error) {
	// var regServiceName string
	var methodInfoList []MethodInfoTree
	var ProtodataArr []ProtoData

	p := &pbParser.Parser{}
	err := p.Parse(string(protoContent))
	if err != nil {
		return nil, err
	}

	for _, service := range p.GetServices() {
		for _, rpc := range service.GetRpcs() {
			tree := MethodInfoTree{
				serviceName:   service.GetServiceName(),
				MethodName:    rpc.GetRpcName(),
				MethodReqName: rpc.GetRpcRequestName(),
				MethodResName: rpc.GetRpcResponseName(),
			}
			methodInfoList = append(methodInfoList, tree)
		}
	}

	protodata := ProtoData{
		Package:        p.GetPackageName(),
		AllMethodInfo:  methodInfoList,
		Timestamp:      time.Now(),
		ProtoImpPath:   protoPath,
		RegServiceName: p.GetServices()[0].GetServiceName(),
		ProtoName:      strings.Split(protoFileName, ".")[0],
	}
	ProtodataArr = append(ProtodataArr, protodata)
	return ProtodataArr, nil
}

// generateServiceImplFile creates implementation files supported for grpc trigger and grpc service
func generateServiceImplFile(pdArr []ProtoData, option string) error {
	dirPath := filepath.Join(appPath)
	_, fileErr := os.Stat(dirPath)
	if fileErr != nil {
		os.MkdirAll(dirPath, os.ModePerm)
	}
	for _, pd := range pdArr {
		connectorFile := filepath.Join(appPath, strings.Split(protoFileName, ".")[0]+"."+pd.RegServiceName+"."+option+".grpcservice.go")
		f, err := os.Create(connectorFile)
		if err != nil {
			log.Fatal("Error: ", err)
			return err
		}
		defer f.Close()
		pd.Option = option
		if strings.Compare(option, "GrpcServer") == 0 {
			err = registryServerTemplate.Execute(f, pd)
		} 
		if err != nil {
			return err
		}
	}
	return nil
}
